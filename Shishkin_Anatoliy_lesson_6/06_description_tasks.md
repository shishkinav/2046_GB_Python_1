# Урок 6. Работа с файлами

## Задание 1
Не используя библиотеки для парсинга, [распарсить](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7)
(получить определённые данные) файл логов web-сервера [nginx_logs.txt](https://github.com/elastic/examples/raw/master/Common%20Data%20Formats/nginx_logs/nginx_logs) 
— получить список кортежей вида: `(<remote_addr>, <request_type>, <requested_resource>)` . 
Например:

```
[
    ...
    ('141.138.90.60', 'GET', '/downloads/product_2'),
    ('141.138.90.60', 'GET', '/downloads/product_2'),
    ('173.255.199.22', 'GET', '/downloads/product_2'),
    ...
]
```

**ВНИМАНИЕ!** Используйте стартовый код для своей реализации:

```(python)
from pprint import pprint


def get_parse_attrs(line: str) -> tuple:
    """Парсит строку на атрибуты и возвращает кортеж атрибутов (<remote_addr>, <request_type>, <requested_resource>)"""
    pass  # Ваша реализация здесь
    return  # верните кортеж значений <remote_addr>, <request_type>, <requested_resource>


list_out = list()
with open('nginx_logs.txt', 'r', encoding='utf-8') as fr:
    pass  # передавайте данные в функцию и наполняйте список list_out кортежами

pprint(list_out)
```

## Задание 2 *(вместо 1)
Найти IP адрес спамера и количество отправленных им запросов по данным файла логов из предыдущего задания.

> Примечание: спамер — это клиент, отправивший больше всех запросов; код должен работать даже с файлами, 
> размер которых превышает объем ОЗУ компьютера.

## Задание 3
Есть два файла `users.csv` и `hobby.csv`: в первом хранятся ФИО пользователей сайта, а во втором — данные об их хобби. 
Известно, что при хранении данных используется принцип: `одна строка — один пользователь, 
разделитель между значениями — запятая`. Написать код, загружающий данные из обоих файлов и формирующий 
из них словарь: `ключи — ФИО, значения — данные о хобби (список строковых переменных)`. 
Сохранить словарь в файл `task_6_3_result.json`. 
Проверить сохранённые данные. Если в файле, хранящем данные о хобби, меньше записей, чем в файле с ФИО, 
задаём в словаре значение `None`. Если наоборот — выходим из скрипта с кодом `1`.

> При решении задачи считать, что объём данных в файлах во много раз меньше объема ОЗУ.

Фрагмент файла с данными о пользователях (users.csv):

```
Иванов,Иван,Иванович
Петров,Петр,Петрович
```

Фрагмент файла с данными о хобби (hobby.csv):

```
скалолазание,охота
горные лыжи
```

**ВНИМАНИЕ!** Используйте стартовый код для своей реализации:

```(python)
import sys
import json


def prepare_dataset(path_users_file: str, path_hobby_file: str) -> dict:
    """
    Считывает данные из файлов и возвращает словарь, где:
        ключ — ФИО, значение — данные о хобби (список строковых переменных)
    :param path_users_file: путь до файла, содержащий ФИО пользователей, разделенных запятой по строке
    :param path_hobby_file: путь до файла, содержащий хобби, разделенные запятой по строке
    :return: Dict(str: Union[List[str]|None])
    """
    # Ваш код пишите здесь

    return  # верните словарь, либо завершите исполнение программы кодом 1


dict_out = prepare_dataset('users.csv', 'hobby.csv')
with open('task_6_3_result.json', 'w', encoding='utf-8') as fw:
    json.dump(dict_out, fw, ensure_ascii=False, indent=2)
```

## Задание 4 *(вместо 3)
Решить задачу 3 для ситуации, когда объём данных в файлах превышает объём ОЗУ (разумеется, не нужно реально 
создавать такие большие файлы, это просто задел на будущее проекта). Только теперь не нужно создавать словарь 
с данными. Вместо этого нужно сохранить объединенные данные в новый файл `users_hobby.txt`. 

Хобби пишем через двоеточие и пробел после ФИО:

```
Иванов,Иван,Иванович: скалолазание,охота
Петров,Петр,Петрович: горные лыжи
```

## Задание 5 **(вместо 4)
Решить задачу 4 и реализовать интерфейс командной строки, чтобы можно было задать имя обоих исходных файлов и 
имя выходного файла. Проверить работу скрипта.

## Задание 6
Реализовать простую систему хранения данных о суммах продаж булочной. 
Должно быть два скрипта `add_sale.py` и `show_sales.py` с интерфейсом командной строки: для записи данных и для вывода на экран записанных данных. 
При записи передавать из командной строки значение суммы продаж. 

Для чтения данных реализовать в командной строке следующую логику:
* просто запуск скрипта — выводить все записи;
* запуск скрипта с одним параметром-числом — выводить все записи с номера, равного этому числу, до конца;
* запуск скрипта с двумя числами — выводить записи, начиная с номера, равного первому числу, по номер, 
  равный второму числу, включительно.

Подумать, как избежать чтения всего файла при реализации второго и третьего случаев.
Данные хранить в файле `bakery.csv` в кодировке `utf-8`. Нумерация записей начинается с `1`. 

Примеры запуска скриптов:

```
$ python add_sale.py 5978,5
$ python add_sale.py 8914,3
$ python add_sale.py 7879,1
$ python add_sale.py 1573,7
$ python show_sales.py
5978,5
8914,3
7879,1
1573,7
$ python show_sales.py 3
7879,1
1573,7
$ python show_sales.py 1 3
5978,5
8914,3
7879,1
```

## Задание 7 *(вместо 6)
Добавить возможность редактирования данных при помощи отдельного скрипта `change_sale.py`: 
передаём ему номер записи и новое значение (нумерация записей начинается с `1`.).

> При этом файл не должен читаться целиком — обязательное требование!!

Предусмотреть ситуацию, когда пользователь вводит номер записи, которой не существует.

> Задачи со * предназначены для продвинутых учеников, которым мало сделать обычное задание.
